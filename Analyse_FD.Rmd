---
title: "First Differences"
author: "Anna Werner & Susumu Shikano"
date: "`r Sys.Date()`"
output: html_document
---
±
```{r , include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stargazer)
```


## Load data

```{r}
load("Data/analysis_dat.RData")
```


## Switch for party selection

```{r}

## Do not select only one party. This won't work!

party.selection <- c(1:6)     # C S A F L G
#party.selection <- c(1:2)     # nur C und S
#party.selection <- c(3:6)     # ohne C und S
#party.selection <- c(3:4,6)   # ohne C, S und L
#party.selection <- c(2:6)     # ohne C
#party.selection <- c(1,3:6)   # ohne S
#party.selection <- c(1:4,6)   # ohne Linke
#party.selection <- c(1:2,4:6) # ohne AfD
#party.selection <- c(2,4:6)   #ohne C und A
#party.selection <- c(1:3,5:6) #ohne F
#party.selection <- c(1:5)      #ohne G
```

## Switch for denominator to compute the vote share

  1: eligible citizens
  2: all voters
  3: all valid votes

```{r}

vote.denom <- 1

```




```{r}
all.abs.votes <- all.abs.votes[,party.selection,,,]
all.treat     <- all.treat[,party.selection,,]
all.rel.votes <-  all.abs.votes/all.abs.total[,rep(vote.denom,length(party.selection)),,,] 

```


## Creating first difference

### Election results

We create the first differences:


```{r}
  all.rel.votes.fd <- all.rel.votes[,,,1:5,1] - all.rel.votes[,,,1:5,2]

  # Note that there will be no FD for 2002, therefore we have n(year)=5.

  hist(all.rel.votes.fd)
```

### Treatment

```{r}

all.treat.dummy <- all.treat
all.treat.dummy[all.treat.dummy>0] <- 1

table(all.treat.dummy)

all.treat.dummy.fd <- array(NA,dim=c(299,length(party.selection),2,5))
for (i.time in 1:5){
  all.treat.dummy.fd[,,,i.time] <-  
    all.treat.dummy[,,,i.time] - all.treat.dummy[,,,i.time+1] 
}

table(all.treat.dummy.fd)

```

## index array

Year index

```{r}
year.index <- all.treat.dummy.fd

year.index[,,,1] <- 2021
year.index[,,,2] <- 2017
year.index[,,,3] <- 2013
year.index[,,,4] <- 2009
year.index[,,,5] <- 2005

table(year.index)

```

Party index

```{r}
party.index <- all.treat.dummy.fd

party.labels <- c("CDU","SPD","AFD","FDP","LIN","GRU")[party.selection]
for (i.party in 1:length(party.selection)){
  party.index[,i.party,,] <- party.labels[i.party]
}

table(party.index)
```

## First difference models

```{r}
library(sandwich)
library("lmtest")

for (i.smdpr in 1:2){ # Loop over Erst- and Zweitstimme

  all.results <- vector("list",3) # empty list to store the results

  votes.in.array <- all.rel.votes.fd[,,i.smdpr,]
  votes <- c(all.rel.votes.fd[,,i.smdpr,] )
  treat <- c(all.treat.dummy.fd[,,i.smdpr,] )
  year  <- as.factor(c(year.index[,,i.smdpr,] ))
  year <- relevel(year,ref="2005")
  party <- factor(c(party.index[,,i.smdpr,] ),
                  levels=c("CDU","SPD","AFD","FDP","LIN","GRU")) # C S A F L G
  party <- relevel(party,ref="CDU")
  cross.treat <- c(all.treat.dummy.fd[,,c(2,1)[i.smdpr],] )

  
  lm.dat <- cbind(votes,treat,cross.treat)
  lm.dat <- as.data.frame(lm.dat)
  lm.dat$year <- year
  lm.dat$party <- party
  lm.dat <- na.omit(lm.dat)
  
  ## Model with year and party fixed effects.
  print(c("Erststimme (H1a)","Zweitstimme  (H1b)")[1])
  print(summary(lm.out <- lm(votes~ treat + year * party, data=lm.dat)))

  print(c("Robust standard error"))
  print(sqrt(diag(vcovHC(lm.out, type = 'HC'))))

  all.results[[1]] <- lm.out
  
  ## Model with cross treatment (contamination)

  print(c("Contamination on Erststimme (H2b)","Contamination on Zweitstimme  (H2a)")[1])
  print(summary(lm.out <- lm(votes~ treat + cross.treat + year * party, data=lm.dat)))
  
  # Adjust standard errors
  print(c("Robust standard error"))
   #print(robust_se <- (sqrt(diag(vcovHC(lm.out, type = 'HC')))))
  print(coeftest(lm.out, vcov = vcovHC(lm.out, type = 'HC')))
  
  # Stargazer output (with and without RSE)
  stargazer(lm.out, coef.rb, type = "text",
          se = list(NULL, robust_se))

  
  all.results[[2]] <- lm.out
  
  all.results[[3]] <- lm.dat
  all.results[[4]] <- votes.in.array
  
  if (i.smdpr==1) all.results.smd <- all.results
  if (i.smdpr==2) all.results.pr <- all.results
}


```

```{r}

t.1a <- 0.0145131/0.005126175
t.1a

t.2b <- 0.0042483/0.000614870
t.2b

t.1a <- 0.0070774/0.0005672975
t.1a

t.2a <- 0.0060133/0.0032950075
t.2a
```

```{r}
ggplot(data = ?, aes(x=))
```

### Diagnostics I: Serial correlated errors

We regress u_t on u_t-1. If the effect is significant, there are serially correlated errors.

Note: We first have to assign individual districts at t to those at t-1.

```{r}

for (i.smdpr in 1:2){
  if (i.smdpr==1){
    to.be.tested <- all.results.smd[[1]]  # Diagnostics for the model Erststimme
    temp.dat <- all.results.smd[[3]]
    temp.depv <- all.results.smd[[4]]

  }else{
    to.be.tested <- all.results.pr[[1]] # Diagnostics for the model Zweitstimme
    temp.dat <- all.results.pr[[3]]
    temp.depv <- all.results.pr[[4]]
  }
  

residuals <- residuals(to.be.tested)
residuals <- array(residuals,dim=dim(temp.depv))

simple.district.idx <- all.wkr.index[,1,1,]

# stacking residuals at t and t-1
## loop from BTW 2021 to 2009

current.resid <- past.resid <- residuals[,,1:4]
for (i.btw in 1:4){
  # create the key to match the current and past districts
  key <- match(simple.district.idx[,i.btw],simple.district.idx[,i.btw+1])
  past.resid[,,i.btw] <- residuals[key,,i.btw+1]
}

print(c("Erststimme","Zweitstimme")[i.smdpr])
print(
   summary(lm.out <- lm(c(current.resid) ~ c(past.resid)))
)
plot(c(current.resid) ~ c(past.resid),
     ylab="t",xlab="t-1")
abline(lm.out)

}

```
```{r}
#pwfdtest(votes~ treat + cross.treat + year * party, data = lm.dat, h0 = "fe")

```


### Diagnostics II: Exogeneity of the treatment

We are testing by using Wooldridge's test. That is, we include the treatment variable at t+1. For this purpose, we lose the most recent BTW 2021.

Also here, we have to take care about the redistricting.



```{r}


for (i.smdpr in 1:2){ # Loop over Erst- and Zweitstimme

  all.results <- vector("list",3) # empty list to store the results

  votes.in.array <- all.rel.votes.fd[,,i.smdpr,2:5]
  votes <- c(votes.in.array)
  treat <- c(all.treat.dummy.fd[,,i.smdpr,2:5] )
  year  <- as.factor(c(year.index[,,i.smdpr,2:5] ))
  year <- relevel(year,ref="2005")
  party <- factor(c(party.index[,,i.smdpr,2:5] ),
                  levels=c("CDU","SPD","AFD","FDP","LIN","GRU")) # C S A F L G
  party <- relevel(party,ref="CDU")
  cross.treat <- c(all.treat.dummy.fd[,,c(2,1)[i.smdpr],2:5] )
  
  # treatment at t+1
  treat.t1 <- all.treat.dummy.fd[,,i.smdpr,1:4] 
  cross.treat.t1 <- all.treat.dummy.fd[,,c(2,1)[i.smdpr],1:4] 
  # we assign the correct district
  simple.district.idx <- all.wkr.index[,1,1,]
  for (i.btw in 2:5){ # loop over btw2017 to btw2005
    key <- match(simple.district.idx[,i.btw],simple.district.idx[,i.btw-1])
    treat.t1[,,i.btw-1] <- treat.t1[key,,i.btw-1]
    cross.treat.t1[,,i.btw-1] <- cross.treat.t1[key,,i.btw-1]
  }
  treat.t1 <- c(treat.t1)
  cross.treat.t1 <- c(cross.treat.t1)

  lm.dat <- cbind(votes,treat,year,party,cross.treat,treat.t1,cross.treat.t1)
  
  ## Model with year and party fixed effects.
  print(c("Erststimme (H1a)","Zweitstimme  (H1b)")[i.smdpr])
  print(summary(lm.out <- lm(votes~ treat + treat.t1+ year * party)))

  all.results[[1]] <- lm.out
  
  ## Model with cross treatment (contamination)

  print(c("Contamination on Erststimme (H2b)","Contamination on Zweitstimme  (H2a)")[i.smdpr])
  print(summary(lm.out <- lm(votes~ treat + treat.t1+
                                     cross.treat + cross.treat.t1+
                               year * party)))
  
  all.results[[2]] <- lm.out
  
  all.results[[3]] <- lm.dat
  all.results[[4]] <- votes.in.array
  
  if (i.smdpr==1) all.results.smd <- all.results
  if (i.smdpr==2) all.results.pr <- all.results
}


```



## NOT COMPLETED!!!!!!!!!!!!!!!


## First difference models with the lagged depenent variable

```{r}


for (i.smdpr in 1:2){ # Loop over Erst- and Zweitstimme

  all.results <- vector("list",3) # empty list to store the results

  votes.in.array <- all.rel.votes.fd[,,i.smdpr,1:4]
  votes <- c(all.rel.votes.fd[,,i.smdpr,1:4] )
  last.votes <- c(all.rel.votes.fd[,,i.smdpr,2:5] )
  treat <- c(all.treat.dummy.fd[,,i.smdpr,1:4] )
  year  <- as.factor(c(year.index[,,i.smdpr,1:4] ))
  year <- relevel(year,ref="2009")
  party <- factor(c(party.index[,,i.smdpr,1:4] ),
                  levels=c("CDU","SPD","AFD","FDP","LIN","GRU")) # C S A F L G
  party <- relevel(party,ref="CDU")
  cross.treat <- c(all.treat.dummy.fd[,,c(2,1)[i.smdpr],1:4] )

  lm.dat <- cbind(votes,last.votes,treat,year,party,cross.treat)
  
  ## Model with year and party fixed effects.
  print(c("Erststimme (H1a)","Zweitstimme  (H1b)")[i.smdpr])
  print(summary(lm.out <- lm(votes~ treat + last.votes + year * party)))

  all.results[[1]] <- lm.out
  
  ## Model with cross treatment (contamination)

  print(c("Contamination on Erststimme (H2b)","Contamination on Zweitstimme  (H2a)")[i.smdpr])
  print(summary(lm.out <- lm(votes~ treat + cross.treat + last.votes + year * party)))
  
  all.results[[2]] <- lm.out
  
  all.results[[3]] <- lm.dat
  all.results[[4]] <- votes.in.array
  
  if (i.smdpr==1) all.results.smd <- all.results
  if (i.smdpr==2) all.results.pr <- all.results
}


```

### Diagnostics I: Serial correlated errors

We regress u_t on u_t-1. If the effect is significant, there are serially correlated errors.

Note: We first have to assign individual districts at t to those at t-1.

```{r}

for (i.smdpd in 1:2){
  if (i.smdpd==1){
    to.be.tested <- all.results.smd[[2]]  # Diagnostics for the model Erststimme
    temp.dat <- all.results.smd[[3]]
    temp.depv <- all.results.smd[[4]]
  }else{
    to.be.tested <- all.results.pr[[2]] # Diagnostics for the model Zweitstimme
    temp.dat <- all.results.pr[[3]]
    temp.depv <- all.results.pr[[4]]
  }
  

residuals <- residuals(to.be.tested)
residuals <- array(residuals,dim=dim(temp.depv))

print(c("Erststimme","Zweitstimme")[i.smdpd])
print(
   
   summary(lm.out <- lm(c(residuals[,,4:2]) ~ c(residuals[,,3:1])))
)
plot(c(residuals[,,4:2]) ~ c(residuals[,,3:1]),
     ylab="t",xlab="t-1")
abline(lm.out)

}

```


### Diagnostics II: Exogeneity of the treatment

We regress the treatment variable on x_t on y_t-1. If the effect is significant, the assumption of the strict exogeneity is violated.

```{r}

# District candidacy: Treatment for SMD
summary(lm(c(all.treat[,,1,]) ~ c(all.rel.votes[,,1,,2])))

# PR list candidacy: Treatment for PR
summary(lm(c(all.treat[,,2,]) ~ c(all.rel.votes[,,2,,2])))


```










## Implementation of Chaisemartin and D’Haultfoeuille's estimator

Not completed...

```{r}

for (i.smdpr in 1:2){ # Loop over Erst- and Zweitstimme

  votes <- all.rel.votes.fd[,,i.smdpr,] 
  treat.raw <- all.treat.dummy[,,i.smdpr,] 
  treat <- all.treat.dummy.fd[,,i.smdpr,] 
  year  <- year.index[,,i.smdpr,] 
  party <- party.index[,,i.smdpr,] 
  cross.treat <- all.treat.dummy.fd[,,c(2,1)[i.smdpr],] 

  treat.types <- treat

  for (i.year in 1:dim(votes)[3]){ # loop over years
    treat.types[,,i.year][treat.raw[,,i.year]==1 & treat.raw[,,i.year+1]==1] <- 2
  }
  table(treat.types)
  
  did.plus <- mean(votes[treat.types==1],na.rm=T) - mean(votes[treat.types==0],na.rm=T)
  did.minus <- mean(votes[treat.types==2],na.rm=T) - mean(votes[treat.types==-1],na.rm=T)
  
  did.est <- (did.plus * sum(treat.types==1) + did.minus * sum(treat.types==-1))/sum(treat.types==1|treat.types==-1)

  print(did.est)
}
```



